# Part 1
### 1. Problem Formulation:
   ##### a. State space: 
            4x5 board with 20 tiles numbered 1-20. As there are 20 numbers to be arranged on the board. There are 20! 
            possibe states. The condition of the board itself we are choosing to represent as a state. So any state 
            consists of the board condition itself.
   ##### b. Successor function: 
            Any legal move of a row or columns (1st, 3rd, and 5th column slide up, 2nd and 4th columns slide down, 1st 
            and 3rd rows slide left, and 2nd and 4th rows slide right).
            Successor function returns 9 new states. Which are generated by making L1,R2,L3,R4,U1,D2,U3,D4,U5 moves on 
            the given state.
   ##### c. Edge weights: 
             Each move of a tile has a cost of 1. So all the successor states are 1 cost away from their predecessor.
   ##### d. Heuristic function: 
             To come up with admissible/consistent heuristic function is a challenge. As it must always underestimate the
            cost to the goal. If we select number of misplaced tiles/neighbours/rows/cols. This is not admissible. As in
            a single move, 4-5 tiles are displaced. We have used following consistent heuristic function.
            H(S) = MAX[min possible moves required to make a tile reach its correct possition], for all tiles.
            So for example, if tile t1 needs 4 moves to reach its ideal position and tile t2 takes 6 moves. Then our 
            heuristic function returns 6.

            As it is evident, that our function underestimates, as to fix the entire board, we will have to make at least
            6 moves.

            Some other heuristic functions explored.
            * Calculating all the misplaced neighbours compared to goal state[a tile has four neighbours]. Now summing 
            all the misplaced neighbours. Now since in one move 10 neighbours can change, we divide the misplaced sum by 10.
            This gives us another heuristic function.
            
            However above heuristic function doesnt yield good results. So we stick with the previous heuristic function.
            
   ##### d. Combining multiple heuristic function:
            Since heuristic functions that we have used are trivial and do not capture much information about the rules 
            of the board. To make implementation slightly faster(still slower though), we combined multiple heuristics.
            
            When two states have same heurustic value, we can return either states. In priority queue implementation, 
            insertion order is followed. That is whichever state was inserted first, is evaluated first.
            In our implementation we use another heuristic function to evaluate these states. And if even that heurustic 
            function doesnt yield good results, we use another heuristic function.

            Another function to help in determining priority of the states was to count number of tiles which have max 
            value. For example if state S1 has two tiles which are 5 steps away from their goal and state S2 has three 
            tiles, which are 5 steps away from the goal. In this case we chose first state. Overall implecation of this 
            is that in our exploration, states which bring farthest tile closer are preferred.

            This in few cases yielded 5-10% faster results. This approach can be thought of as combining multiple dumb 
            heuristics to create slightly intelligent heuristic.

### 2. How it works:
            We start with start state and keep on inserting the successor states with their priority value calculated 
            through A*. We continue this exploration untill goal state is reached.
      
### 3. Problems faced and design decisions:
            Figuring out minimum moves required by a tile to reach its goal position.
            
      

# Part 2
### 1. Problem Formulation:
  ##### a. State space: 
            State space consists of the paths. All possible paths from start state are part of state space. If we consider
            the branching factor to be 3 on average, then there is an exponential growth of state space, with increasing depth.

  ##### b. Successor function: 
            Successor function returns all the nodes that can be reached from the current node. To find out all the 
            states that are possible from current state, we check all the path segments that are possible from that node
            to generate the successor states.
  ##### c. Edge weights: 
            The weights depends on the user's choice of cost function of either number of road segments, total distance, 
            fastest route, or safest route. In case of distance, it is the distnce of the segment. In case of time it 
            is the distance/speed of that segment. In case of segment, it is always one. In case of safe, it is the accident
            expectation of that segment.
  ##### d. Heuristic function: TODO 
            If two successor states have the same cost, then a heuristic is used to determine which successor has a smaller distance to the goal city based on the difference
            between latitude and longitude. The successor with the smaller distance is the one chosen by the agent. 
### 2. How it works: TODO
            The program begins by placing the first state in the priority queue into the fringe. The program checks if the current state is the goal city. If it is, then the
            goal state is translated into route taken, total miles, total hours, and total accidents. If it is not the goal state, then each path (city) in the current state
            is checked to see if it has already been visited by the agent. If it has been visited before, then the program moves to the next path in the state. If the path has
            not been visited previously, then it is added to the fringe as the cost function defined by the user. It is also added to the visited cities list to prevent
            returning to the same location. The process continues until the goal city is found by the agent. 
### 3. Problems faced and design decisions:

# Part 3
### 1. Problem Formulation:
Find the groups of students which results in least complaints. On initial analysis, total number of groups of size less 
than or equal to 3 from given 'n' students were calculated using python program.
Following were the results.
1 -> 1 |
2 -> 2 |
3 -> 5 |
4 -> 14 |
5 -> 46 |
6 -> 166 |
7 -> 652 |
8 -> 2780 |
9 -> 12644 |
10 -> 61136 |
11 -> 312676 |

Total number of results increase factorially. So for large set of students, it will be exhaustive to search through all 
possible combinations. 

We have formulated the problem in following way:
1) there is a basic initial state, which is used to generate next possible states. For our case this state is a set of 
   groups where each individual person is present and no other person is part of group.
2) To generate next successor states, every two groups are merged. The merge happens in such a way that the size doesnt 
   exceed "three".
3) For each of these next states, the cost(#complain) is calculated and inserted into the fringe. which acts as a priority.
4) While searching through the states, if a state is reached, which has minimum #complaints, then it is yielded.


  ##### a. State space: 
            All possible groupings of students. We have calculated total number of groups possible with 'n' students and
            it shows factorial growth in the number of distinct groups possible. Here are the results for first 11 numbers.
            1 -> 1 
            2 -> 2 
            3 -> 5 
            4 -> 14 
            5 -> 46 
            6 -> 166 
            7 -> 652 
            8 -> 2780 
            9 -> 12644 
            10 -> 61136 
            11 -> 312676
  ##### b. Initial state:
            In the initial state, each group has only one person, that is the person himself. So in the beginning there
            are n groups, if there are n students.
  ##### c. Successor function: 
            Following requirements were expected of the successor function.
            * We should be able to generate all possible states, that are possible.
            * A state should not be generated again and again. That is we should make sure that same state is not being 
            generated again and again, this will make our seach faster. As the state space is already very exhaustive.

            Based on above points, we have come up with following successor function. if S is a state containing {g1, g2,...gn} 
            groups. Then successor function combines all possible two groups to get the next possible states. However the merging
            two groups must follow following rules.
            1) Combine groups g_i with g_j if i < j and cardinality of g_j = 1
            2) The resulting group must be of size not more than 3
            3) there does not exist a group g_k with cardinality > 1, for k > i
            
            Using above rules of successor function, we get unique groups each time that have not been generated before. 
            This avoid situation where one group is possible through various paths. 
            For example consider a state = [(1,2,3), (4)]
            This is possible through [(1,2), (3), (4)] OR [(1,3), (2), (4)]

            Writing our successor function in a way that it doesnt generate same state again, makes our solution slightly faster, 
            as it will have to process less number of states. 
 
            
  ##### d. Edge weights: 
            Edge weight for all the successor states is the same, which is equal to one.
  ##### e. Heuristic function: 
            Heuristic function here is the total number of complaints. So for state S1 and S2, the fringe will give 
            priority to the state which generates less number of complaints. And that state will be explored first.
            It is important to note here, that the heuristic function here does not calculate/estimate the distance from
            goal state, instead heuristic function here tells the priority of a state. So for example if the heuristic 
            value of a state S, h(S) = x, then it doesnt mean the goal state is x steps away.

            Heuristic function is here is the evaluation of how good a state is compared to other.

            g(s) for any state is zero. This helps us process states which generate less complaints faster. To understand 
            this, lets consider there are two states in the fringe S1: (F(S1) = 10 + 3) and S2: (F(S2) = 5)
            In this case, we would want to process S2 first. Because we aren't considering the distance from initial state here.
            Our algorithm is exploring a state space and not necessarily going from one start state to goal state.
### 2. How it works:
        Initially all the userid are in individual group, new groups are formed by merging groups. The states with lease
        number of complaints are explored first.  
        
### 3. Problems faced and design decisions:
        Problems faced.
        Figuring out a successor function which generates unique state and doesn't repeat states.
        
        Approaches tried:
        When two states are equal, that is both states generate equal number of complaints. In this case we can process 
        any state first. However if we intelligently use another heuristic function on both the states, we can benefit by
        processing better state first. Recursively if the second heuristic also returns equal value for both states, then
        a third heuristic can be used. As a second function, to compare two states, we choose a state, which has a user 
        complaining the most. However this did not result in much improvements so it was left out of implementation.
        