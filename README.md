# Part 1
### 1. Problem Formulation:
   ##### a. State space: 
            4x5 board with 20 tiles numbered 1-20. As there are 20 numbers to be arranged on the board. There are 20! 
            possibe states. The condition of the board itself we are choosing to represent as a state. So any state 
            consists of the board condition itself.
   ##### b. Successor function: 
            Any legal move of a row or columns (1st, 3rd, and 5th column slide up, 2nd and 4th columns slide down, 1st 
            and 3rd rows slide left, and 2nd and 4th rows slide right).
            Successor function returns 9 new states. Which are generated by making L1,R2,L3,R4,U1,D2,U3,D4,U5 moves on 
            the given state.
   ##### c. Edge weights: 
             Each move of a tile has a cost of 1. So all the successor states are 1 cost away from their predecessor.
   ##### d. Heuristic function: 
             To come up with admissible/consistent heuristic function is a challenge. As it must always underestimate the
            cost to the goal. If we select number of misplaced tiles/neighbours/rows/cols. This is not admissible. As in
            a single move, 4-5 tiles are displaced. We have used following consistent heuristic function.
            H(S) = MAX[min possible moves required to make a tile reach its correct possition], for all tiles.
            So for example, if tile t1 needs 4 moves to reach its ideal position and tile t2 takes 6 moves. Then our 
            heuristic function returns 6.

            As it is evident, that our function underestimates, as to fix the entire board, we will have to make at least
            6 moves.

            Some other heuristic functions explored.
            * Calculating all the misplaced neighbours compared to goal state[a tile has four neighbours]. Now summing 
            all the misplaced neighbours. Now since in one move 10 neighbours can change, we divide the misplaced sum by 10.
            This gives us another heuristic function.
            
            However above heuristic function doesnt yield good results. So we stick with the previous heuristic function.
            
   ##### d. Combining multiple heuristic function:
            Since heuristic functions that we have used are trivial and do not capture much information about the rules 
            of the board. To make implementation slightly faster(still slower though), we combined multiple heuristics.
            
            When two states have same heurustic value, we can return either states. In priority queue implementation, 
            insertion order is followed. That is whichever state was inserted first, is evaluated first.
            In our implementation we use another heuristic function to evaluate these states. And if even that heurustic 
            function doesnt yield good results, we use another heuristic function.

            Another function to help in determining priority of the states was to count number of tiles which have max 
            value. For example if state S1 has two tiles which are 5 steps away from their goal and state S2 has three 
            tiles, which are 5 steps away from the goal. In this case we chose first state. Overall implecation of this 
            is that in our exploration, states which bring farthest tile closer are preferred.

            This in few cases yielded 5-10% faster results. This approach can be thought of as combining multiple dumb 
            heuristics to create slightly intelligent heuristic.

### 2. How it works:
            We start with start state and keep on inserting the successor states with their priority value calculated 
            through A*. We continue this exploration untill goal state is reached.
      
### 3. Problems faced and design decisions:
            1) Figuring out minimum moves required by a tile to reach its goal position.
            
            2) To generate boards, We have created an extra function, which makes the move on the board and alters it. 
            So for example if I make R1 move on the board, then the solution will have L1 move. 
            Likewise If we make R1 D1 D3 move, then the correct solution will have L1 U1 U3 in the solution or less.   
            
      

# Part 2
### 1. Problem Formulation:
  ##### a. State space: 
            State space consists of the paths. All possible paths from start state are part of state space. If we consider
            the branching factor to be 3 on average, then there is an exponential growth of state space, with increasing depth.

  ##### b. Successor function: 
            Successor function returns all the nodes that can be reached from the current node. To find out all the 
            states that are possible from current state, we check all the path segments that are possible from that node
            to generate the successor states.
  ##### c. Edge weights: 
            The weights depends on the user's choice of cost function of either number of road segments, total distance, 
            fastest route, or safest route. In case of distance, it is the distnce of the segment. In case of time it 
            is the distance/speed of that segment. In case of segment, it is always one. In case of safe, it is the accident
            expectation of that segment.
  ##### d. Heuristic function:  
            In the initial implementation we tried using h(s) = 0, with best first approach. Since h(s) = 0 is consistent.
            As discussed during lectures, an algorithm is optimal if algorithm #3 is used with consistent heuristic. 
            Since h(s) = 0 is always consistent, the algorithm finds optimal paths.             
### 2. How it works: 
            We maintain a separate variable named closed_cities, this variable stores the states that have already been 
            explored. Which means it stores the states for which we have explored successors.
            
            Next we use algorithm #3 with replacing/discarding visited states as follows.
            1) If a new successor state is in closed cities, then we discard that state.
            2) If a new successor state is already in fringe, then we replace that state in fringe, iff the new path 
            found has less f(s) value.
                2.1) As PriorityQueue implementation in python doesnt allow updation of an element, we do not update the
                state in the fringe, instead, we are simply inserting the state in the fringe again. Since it is 
                priority queue, the newly inserted state is explored first. After exploration, this state is added in 
                closed_cities set. The duplicate state which is in fringe, when popped from the fringe is immediately 
                discarded, because it is now in closed_cities.

            As we know consistent heuristic(Even though h(s) = 0 always) with algorithm #3 is optimal. Our implementation 
            finds the optimal path everytime.

### 3. More improvements: 
            We can use lat, lng provided in the dataset, to direct our search in a specific direction. This will explore
            much lower number of states than previoud approach. In other way, we can supply 
            h(s) = distance between lat,lng of current city and the target city. This approach reduces number of nodes 
            explored significantly.
            
            However on exploring the solution with heuristic which used lat lng, we found that there were some inconsistencies
            in the dataset. Example: https://inscribe.education/main/indianau/6754110229500553/questions/6749461749551022?backToListTab=conversations
            In the route.py file, we have commented the code which detects inconsistencies. 
            Search for "INCONSISTENCY DETECTION CODE" in route.py and uncomment the code to list the inconsistencies in the path segments.
            1) Uncomment the code as stated above.
            2) Set "ENABLE_HEURISTIC = True" to use heuristic function. However this returns inconsistent results.
            
            For now the Heuristic evaluation of states based on the lat, lng it turned off.
### 4. Problems faced and design decisions:
            * Inconsistencies in data. Which took a lot of time to figure out why we are getting suboptimal results.
# Part 3
### 1. Problem Formulation:
Find the groups of students which results in least complaints. On initial analysis, total number of groups of size less 
than or equal to 3 from given 'n' students were calculated using python program.
Following were the results.
1 -> 1 |
2 -> 2 |
3 -> 5 |
4 -> 14 |
5 -> 46 |
6 -> 166 |
7 -> 652 |
8 -> 2780 |
9 -> 12644 |
10 -> 61136 |
11 -> 312676 |

Total number of results increase factorially. So for large set of students, it will be exhaustive to search through all 
possible combinations. 

We have formulated the problem in following way:
1) there is a basic initial state, which is used to generate next possible states. For our case this state is a set of 
   groups where each individual person is present and no other person is part of group.
2) To generate next successor states, every two groups are merged. The merge happens in such a way that the size doesnt 
   exceed "three".
3) For each of these next states, the cost(#complain) is calculated and inserted into the fringe. which acts as a priority.
4) While searching through the states, if a state is reached, which has minimum #complaints, then it is yielded.


  ##### a. State space: 
            All possible groupings of students. We have calculated total number of groups possible with 'n' students and
            it shows factorial growth in the number of distinct groups possible. Here are the results for first 11 numbers.
            1 -> 1 
            2 -> 2 
            3 -> 5 
            4 -> 14 
            5 -> 46 
            6 -> 166 
            7 -> 652 
            8 -> 2780 
            9 -> 12644 
            10 -> 61136 
            11 -> 312676
  ##### b. Initial state:
            In the initial state, each group has only one person, that is the person himself. So in the beginning there
            are n groups, if there are n students.
  ##### c. Successor function: 
            Following requirements were expected of the successor function.
            * We should be able to generate all possible states, that are possible.
            * A state should not be generated again and again. That is we should make sure that same state is not being 
            generated again and again, this will make our seach faster. As the state space is already very exhaustive.

            Based on above points, we have come up with following successor function. if S is a state containing {g1, g2,...gn} 
            groups. Then successor function combines all possible two groups to get the next possible states. However the merging
            two groups must follow following rules.
            1) Combine groups g_i with g_j if i < j and cardinality of g_j = 1
            2) The resulting group must be of size not more than 3
            3) there does not exist a group g_k with cardinality > 1, for k > i
            
            Using above rules of successor function, we get unique groups each time that have not been generated before. 
            This avoid situation where one group is possible through various paths. 
            For example consider a state = [(1,2,3), (4)]
            This is possible through [(1,2), (3), (4)] OR [(1,3), (2), (4)]

            Writing our successor function in a way that it doesnt generate same state again, makes our solution slightly faster, 
            as it will have to process less number of states. 
 
            
  ##### d. Edge weights: 
            Edge weight for all the successor states is the same, which is equal to one.
  ##### e. Heuristic function: 
            Heuristic function here is the total number of complaints. So for state S1 and S2, the fringe will give 
            priority to the state which generates less number of complaints. And that state will be explored first.
            It is important to note here, that the heuristic function here does not calculate/estimate the distance from
            goal state, instead heuristic function here tells the priority of a state. So for example if the heuristic 
            value of a state S, h(S) = x, then it doesnt mean the goal state is x steps away.

            Heuristic function is here is the evaluation of how good a state is compared to other.

            g(s) for any state is zero. This helps us process states which generate less complaints faster. To understand 
            this, lets consider there are two states in the fringe S1: (F(S1) = 10 + 3) and S2: (F(S2) = 5)
            In this case, we would want to process S2 first. Because we aren't considering the distance from initial state here.
            Our algorithm is exploring a state space and not necessarily going from one start state to goal state.
### 2. How it works:
        Initially all the userid are in individual group, new groups are formed by merging groups. The states with lease
        number of complaints are explored first.  
        
### 3. Problems faced and design decisions:
        Problems faced.
        Figuring out a successor function which generates unique state and doesn't repeat states.
        
        Approaches tried:
        When two states are equal, that is both states generate equal number of complaints. In this case we can process 
        any state first. However if we intelligently use another heuristic function on both the states, we can benefit by
        processing better state first. Recursively if the second heuristic also returns equal value for both states, then
        a third heuristic can be used. As a second function, to compare two states, we choose a state, which has a user 
        complaining the most. However this did not result in much improvements so it was left out of implementation.
        